<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Learning Lab</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

  <div id="landing">
    <div id="landing-hero">
      <div class="hero-content">
        <h1 class="app-title">AI Learning Lab</h1>
        <p class="tagline">Resume a conversation or start a new one.</p>
        <div class="hero-actions">
          <button id="new-convo-btn" class="primary">Start New</button>
          <button id="settings-btn" title="Settings">‚öôÔ∏è Settings</button>
        </div>
      </div>
    </div>
    <h2 class="section-title">Your Conversations</h2>
    <div id="settings-panel" style="display:none; margin-bottom:1rem">
      <h2>API Keys</h2>
      <div id="api-keys-required" style="margin-bottom:0.5rem"></div>
      <div id="api-keys-list"></div>
      <button id="add-key-btn">Add Key</button>
      <button id="close-settings-btn">Close</button>
    </div>
    <div id="conversations"></div>
  </div>

  <div id="chat-interface">
    <input type="hidden" id="user-id" />
    <div id="topbar">
      <button id="back-btn" title="Back to conversations">‚üµ Back</button>
      <img id="profile-avatar" src="" alt="avatar" />
      <span id="profile-name"></span>
      <span class="title">AI Learning Lab</span>
    </div>
    <div id="container">
      <div id="sidebar">
        <h3>Configuration</h3>
        <label for="persona-select">Character:</label>
        <select id="persona-select">
          <option value="">(loading‚Ä¶)</option>
        </select>
        <div style="margin-top:0.5rem">
          <button id="new-character-btn">New</button>
          <button id="edit-character-btn">Edit</button>
          <button id="delete-character-btn">Delete</button>
          <button id="view-prompt-btn" title="View current full system prompt">View Prompt</button>
        </div>
        <div id="new-character-form" style="display:none; margin-top:0.5rem">
          <p>Character's Name:</p>
          <input id="char-name" type="text" placeholder="Name" style="width:100%; margin-bottom:0.3rem"/>
          <div style="position: relative;">
            <p>Quick generate character behaviour:</p>
            <button id="quick-prompt-btn" type="button" title="Prompt Wizard">Generate ü™Ñ</button>
            <p>Or describe your character here:</p>
            <textarea id="char-prompt" placeholder="System prompt (persona)" rows="4" style="width:100%; margin-bottom:0.3rem; padding-right:2.2rem"></textarea>
            
          </div>
          <p>Have an avatar saved locally?  Provide the path here:</p>
          <input id="char-avatar" type="text" placeholder="Avatar URL (optional)" style="width:100%; margin-bottom:0.3rem"/>
          <p>Select character voice:</p>
          <label for="char-voice">Voice:</label>
          <select id="char-voice" style="width:100%; margin-bottom:0.25rem">
            <option value="">(use current voice)</option>
          </select>
          <div id="char-voice-tools" style="display:flex; gap:0.5rem; align-items:center; margin-bottom:0.5rem">
            <button id="char-voice-reload" type="button" class="icon-btn" title="Reload available voices">‚ü≥ Reload</button>
            <button id="char-voice-manual-toggle" type="button" class="icon-btn" title="Enter a voice ID manually">‚úé Manual ID</button>
            <span id="char-voice-hint" style="font-size:0.9em; opacity:0.8"></span>
          </div>
          <input id="char-voice-manual" type="text" placeholder="Enter ElevenLabs voice_id (optional)" style="width:100%; display:none; margin-bottom:0.5rem" />
          <div style="margin-bottom:0.5rem">
            <label for="char-avatar-prompt">Avatar Image Prompt (to generate image):</label>
            <textarea id="char-avatar-prompt" placeholder="Describe the look (kid‚Äësafe)" rows="2" style="width:100%; margin-top:0.25rem"></textarea>
          </div>
          <div style="margin-bottom:0.5rem">
            <label for="char-avatar-style">Avatar Style:</label>
            <select id="char-avatar-style" style="width:100%; margin-top:0.25rem">
              <option value="friendly colorful cartoon portrait">Cartoon</option>
              <option value="storybook watercolor illustration">Storybook</option>
              <option value="bright sci-fi cartoon, kid-safe">Sci‚ÄëFi</option>
              <option value="whimsical fantasy cartoon, kid-safe">Fantasy</option>
              <option value="minimalist flat vector avatar, kid-safe">Minimal</option>
            </select>
            <label for="char-avatar-size" style="display:block; margin-top:0.5rem">Avatar Size:</label>
            <select id="char-avatar-size" style="width:100%; margin-top:0.25rem">
              <option value="1024x1024" selected>1024 x 1024</option>
              <option value="1024x1792">1024 x 1792 (portrait)</option>
          <div style="margin-top:0.5rem">
            <label>
              <input type="checkbox" id="char-avatar-include-sp" />
              Include character system prompt (may cause rejections)
            </label>
          </div>
              <option value="1792x1024">1792 x 1024 (landscape)</option>
            </select>
          </div>
          <div>
            <button id="save-character-btn">Save</button>
            <button id="cancel-character-btn" type="button">Cancel</button>
            <button id="generate-avatar-btn" type="button" title="Generate avatar from prompt">Generate Avatar</button>
          </div>
        </div>
      <div id="chat-area">
        <div id="chat-avatar-bg" aria-hidden="true"></div>
        <div id="chat"></div>
        <div id="input-area">
          <textarea id="prompt" placeholder="Say something... (Shift+Enter for newline)" rows="3"></textarea>
          <button id="send-btn">Send</button>
          <button id="listen-btn" title="Push-to-talk (Shift+S)">üé§</button>
          <span id="recording-hint" aria-live="polite">Recording‚Ä¶</span>
          <select id="speech-toggle" title="Speech synthesis for replies">
            <option value="on" selected>Speak: On</option>
            <option value="off">Speak: Off</option>
          </select>
          <span class="export-controls">
            <select id="export-format" title="Export conversation as">
              <option value="markdown" selected>Export: Markdown</option>
              <option value="json">Export: JSON</option>
              <option value="text">Export: Text</option>
            </select>
            <button id="export-btn" title="Download conversation">Export</button>
            <button id="import-btn" title="Import conversation JSON">Import</button>
            <input id="import-file" type="file" accept="application/json" style="display:none" />
          </span>
        </div>
        <!-- voice-config removed: voice now configured per character in the editor -->
      </div>

      </div>
    </div>
  </div>


  <script src="config.js"></script>
  <script>
    // --- Prompt Wizard (native dialog) ---
    const wizardDialog = document.createElement('dialog');
    wizardDialog.id = 'prompt-wizard-dialog';
    wizardDialog.innerHTML = `
      <form method="dialog" id="prompt-wizard" class="pw">
        <div class="pw-header">
          <strong>Prompt Wizard</strong>
          <button class="pw-close" value="cancel" title="Close">‚úñ</button>
        </div>
        <div class="pw-body">
          <div class="pw-row">
            <label>Genres:</label>
            <div class="pw-grid">
              ${['sci-fi','fantasy','adventure','drama','mystery','comedy','historical','educational'].map(g => `
                <label><input type="checkbox" name="pw-genre" value="${g}"> ${g}</label>
              `).join('')}
            </div>
          </div>
          <div class="pw-row">
            <label>Gender:</label>
            <div class="pw-grid">
              ${['female','male','non-binary','gender-neutral','unspecified'].map(g => `
                <label><input type="radio" name="pw-gender" value="${g}"> ${g}</label>
              `).join('')}
            </div>
          </div>
          <div class="pw-row">
            <label>Archetypes:</label>
            <div class="pw-grid">
              ${['hero','sage','mentor','trickster','guardian','rebel','healer','demon','dragon','elemental','explorer'].map(a => `
                <label><input type="checkbox" name="pw-arch" value="${a}"> ${a}</label>
              `).join('')}
            </div>
          </div>
          <div class="pw-row">
            <label>Personality Traits:</label>
            <div class="pw-grid">
              ${['curious','patient','humorous','supportive','wise','playful','stoic','optimistic','analytical','kind','adventurous'].map(t => `
                <label><input type="checkbox" name="pw-trait" value="${t}"> ${t}</label>
              `).join('')}
            </div>
          </div>
          <div class="pw-row">
            <label>Style Hints (optional):</label>
            <input id="pw-style" type="text" placeholder="e.g., kid-safe, G-rated, simple language">
          </div>
          <div class="pw-actions">
            <button id="pw-generate" type="button">Generate</button>
            <button id="pw-cancel" type="button" class="secondary">Cancel</button>
          </div>
          <div id="pw-error" class="pw-error" role="alert"></div>
        </div>
      </form>`;
    document.body.appendChild(wizardDialog);

    function openPromptWizard() {
      try { document.getElementById('pw-error').textContent = ''; } catch {}
      if (typeof wizardDialog.showModal === 'function') {
        wizardDialog.showModal();
      } else {
        wizardDialog.setAttribute('open', '');
      }
    }
    function closePromptWizard() {
      try { wizardDialog.close && wizardDialog.close(); } catch {}
      wizardDialog.removeAttribute('open');
    }

    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'quick-prompt-btn') openPromptWizard();
      if (e.target && (e.target.classList?.contains('pw-close') || e.target.id === 'pw-cancel')) closePromptWizard();
    });
    wizardDialog.addEventListener('cancel', (e) => { e.preventDefault(); closePromptWizard(); });

    async function generatePromptFromWizard() {
      const getValues = (name) => Array.from(document.querySelectorAll(`input[name="${name}"]:checked`)).map(i => i.value);
      const genres = getValues('pw-genre');
      const archetypes = getValues('pw-arch');
      const traits = getValues('pw-trait');
      const genderEl = document.querySelector('input[name="pw-gender"]:checked');
      const gender = genderEl ? genderEl.value : 'unspecified';
      const style = document.getElementById('pw-style').value.trim();

      const payload = { genres, archetypes, traits, gender, style };
      const btn = document.getElementById('pw-generate');
      const err = document.getElementById('pw-error');
      err.textContent = '';
      btn.disabled = true;
      const old = btn.textContent;
      btn.textContent = 'Generating‚Ä¶';
      btn.classList.add('loading');
      try {
        const res = await fetch(`${API_BASE}/characters/suggest_system_prompt`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        const text = (data && data.prompt) || '';
        if (text) {
          const ta = document.getElementById('char-prompt');
          ta.value = text;
          closePromptWizard();
        } else {
          throw new Error('Empty suggestion');
        }
      } catch (e) {
        // Fallback: local template
        const base = `You are a helpful ${gender} ${archetypes.join(', ')} guide with ${traits.join(', ')} traits, grounded in ${genres.join(', ')} themes. ${style || 'Use friendly, age-appropriate language.'}`.replace(/\s+/g,' ').trim();
        try { document.getElementById('char-prompt').value = base; } catch {}
        err.textContent = 'Used local template (suggestion service unavailable).';
      } finally {
        btn.disabled = false;
        btn.textContent = old;
        btn.classList.remove('loading');
      }
    }
    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'pw-generate') generatePromptFromWizard();
    });

    // --- New Conversation Modal ---
    const newConvoDialog = document.createElement('dialog');
    newConvoDialog.id = 'new-convo-dialog';
    newConvoDialog.innerHTML = `
      <form method="dialog" id="new-convo-form" style="min-width: min(92vw, 420px); max-width: 92vw; background:#2a2a2a; color:#e0e0e0; border:1px solid #666; border-radius:8px; padding:0.8rem;">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.5rem;">
          <strong>New Conversation</strong>
          <button value="cancel" title="Close" style="border:1px solid #666; background:#3a3a3a; color:#e0e0e0; border-radius:4px; padding:0.2rem 0.5rem; cursor:pointer">‚úñ</button>
        </div>
        <label for="new-convo-name" style="display:block; margin: 0.25rem 0;">Name</label>
        <input id="new-convo-name" type="text" placeholder="e.g., Conversation 2025-08-29 12:00" style="width:100%; padding:0.5rem; border:1px solid #555; background:#1f1f1f; color:#e0e0e0; border-radius:4px;" />
        <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.8rem;">
          <button id="nc-cancel" type="button" class="secondary" style="border:1px solid #666; background:#3a3a3a; color:#e0e0e0; border-radius:4px; padding:0.4rem 0.8rem; cursor:pointer">Cancel</button>
          <button id="nc-create" type="button" style="border:1px solid #666; background:#4a4a4a; color:#fff; border-radius:4px; padding:0.4rem 0.8rem; cursor:pointer">Create</button>
        </div>
      </form>`;
    document.body.appendChild(newConvoDialog);

    function openNewConvoDialog() {
      try {
        const input = newConvoDialog.querySelector('#new-convo-name');
        if (input) input.value = '';
      } catch {}
      if (typeof newConvoDialog.showModal === 'function') newConvoDialog.showModal();
      else newConvoDialog.setAttribute('open','');
      try { newConvoDialog.querySelector('#new-convo-name')?.focus(); } catch {}
    }
    function closeNewConvoDialog() {
      try { newConvoDialog.close && newConvoDialog.close(); } catch {}
      newConvoDialog.removeAttribute('open');
    }
    async function submitNewConversation() {
      let name = '';
      try { name = (newConvoDialog.querySelector('#new-convo-name').value || '').trim(); } catch {}
      if (!name) {
        const ts = new Date().toISOString().replace('T',' ').replace(/[:].*/, '');
        name = `Conversation ${ts}`;
      }
      try {
	  const res = await fetch(`${API_BASE}/users`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        if (!res.ok) throw new Error('Create failed');
        const data = await res.json();
        closeNewConvoDialog();
        // Open it immediately
        selectConversation({ id: data.id, name: data.name });
      } catch (e) {
        // Keep modal open but provide subtle feedback
        console.error('Could not create conversation', e);
      }
    }
    newConvoDialog.addEventListener('cancel', (e) => { e.preventDefault(); closeNewConvoDialog(); });
    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'nc-cancel') { closeNewConvoDialog(); }
      if (e.target && e.target.id === 'nc-create') { submitNewConversation(); }
    });
    document.addEventListener('keydown', (e) => {
      if (newConvoDialog.hasAttribute('open') && e.key === 'Enter') {
        const active = document.activeElement;
        if (active && active.id === 'new-convo-name') {
          e.preventDefault();
          submitNewConversation();
        }
      }
    });

    // --- Delete Conversation Modal ---
    const deleteConvoDialog = document.createElement('dialog');
    deleteConvoDialog.id = 'delete-convo-dialog';
    deleteConvoDialog.innerHTML = `
      <form method="dialog" id="delete-convo-form" style="min-width: min(92vw, 420px); max-width: 92vw; background:#2a2a2a; color:#e0e0e0; border:1px solid #666; border-radius:8px; padding:0.8rem;">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.5rem;">
          <strong>Delete Conversation</strong>
          <button value="cancel" title="Close" style="border:1px solid #666; background:#3a3a3a; color:#e0e0e0; border-radius:4px; padding:0.2rem 0.5rem; cursor:pointer">‚úñ</button>
        </div>
        <div id="dc-message" style="margin:0.25rem 0 0.5rem 0; line-height:1.4"></div>
        <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.8rem;">
          <button id="dc-cancel" type="button" class="secondary" style="border:1px solid #666; background:#3a3a3a; color:#e0e0e0; border-radius:4px; padding:0.4rem 0.8rem; cursor:pointer">Cancel</button>
          <button id="dc-confirm" type="button" style="border:1px solid #803333; background:#a33; color:#fff; border-radius:4px; padding:0.4rem 0.8rem; cursor:pointer">Delete</button>
        </div>
      </form>`;
    document.body.appendChild(deleteConvoDialog);

    let deleteTargetUserId = null;
    let deleteTargetUserName = '';
    function openDeleteConvoDialog(user) {
      deleteTargetUserId = user && user.id;
      deleteTargetUserName = (user && user.name) || '';
      const msg = deleteConvoDialog.querySelector('#dc-message');
      if (msg) {
        const name = deleteTargetUserName ? `‚Äú${deleteTargetUserName}‚Äù` : 'this conversation';
        msg.textContent = `Are you sure you want to delete ${name}? This cannot be undone.`;
      }
      if (typeof deleteConvoDialog.showModal === 'function') deleteConvoDialog.showModal();
      else deleteConvoDialog.setAttribute('open','');
    }
    function closeDeleteConvoDialog() {
      try { deleteConvoDialog.close && deleteConvoDialog.close(); } catch {}
      deleteConvoDialog.removeAttribute('open');
      deleteTargetUserId = null;
      deleteTargetUserName = '';
    }
    async function confirmDeleteConversation() {
      if (!deleteTargetUserId) { closeDeleteConvoDialog(); return; }
      try {
        const resp = await fetch(`${API_BASE}/users/${deleteTargetUserId}`, { method: 'DELETE' });
        if (!resp.ok) throw new Error('Delete failed');
        closeDeleteConvoDialog();
        loadConversations();
      } catch (e) {
        console.error('Delete failed', e);
        alert('Delete failed');
      }
    }
    deleteConvoDialog.addEventListener('cancel', (e) => { e.preventDefault(); closeDeleteConvoDialog(); });
    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'dc-cancel') { closeDeleteConvoDialog(); }
      if (e.target && e.target.id === 'dc-confirm') { confirmDeleteConversation(); }
    });

    // --- Delete Character Modal ---
    const deleteCharDialog = document.createElement('dialog');
    deleteCharDialog.id = 'delete-char-dialog';
    deleteCharDialog.innerHTML = `
      <form method=\"dialog\" id=\"delete-char-form\" style=\"min-width: min(92vw, 420px); max-width: 92vw; background:#2a2a2a; color:#e0e0e0; border:1px solid #666; border-radius:8px; padding:0.8rem;\">
        <div style=\"display:flex; align-items:center; justify-content:space-between; margin-bottom:0.5rem;\">
          <strong>Delete Character</strong>
          <button value=\"cancel\" title=\"Close\" style=\"border:1px solid #666; background:#3a3a3a; color:#e0e0e0; border-radius:4px; padding:0.2rem 0.5rem; cursor:pointer\">‚úñ</button>
        </div>
        <div id=\"dchar-message\" style=\"margin:0.25rem 0 0.5rem 0; line-height:1.4\"></div>
        <div style=\"display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.8rem;\">
          <button id=\"dchar-cancel\" type=\"button\" class=\"secondary\" style=\"border:1px solid #666; background:#3a3a3a; color:#e0e0e0; border-radius:4px; padding:0.4rem 0.8rem; cursor:pointer\">Cancel</button>
          <button id=\"dchar-confirm\" type=\"button\" style=\"border:1px solid #803333; background:#a33; color:#fff; border-radius:4px; padding:0.4rem 0.8rem; cursor:pointer\">Delete</button>
        </div>
      </form>`;
    document.body.appendChild(deleteCharDialog);
    let deleteTargetCharId = null;
    let deleteTargetCharName = '';
    function openDeleteCharDialog() {
      const id = personaSelect.value;
      if (!id) { alert('Select a character first'); return; }
      const ch = (characters || []).find(c => String(c.id) === String(id));
      deleteTargetCharId = id;
      deleteTargetCharName = ch ? (ch.name || '') : '';
      const msg = deleteCharDialog.querySelector('#dchar-message');
      if (msg) {
        const name = deleteTargetCharName ? `‚Äú${deleteTargetCharName}‚Äù` : 'this character';
        msg.textContent = `Are you sure you want to delete ${name}? This cannot be undone.`;
      }
      if (typeof deleteCharDialog.showModal === 'function') deleteCharDialog.showModal();
      else deleteCharDialog.setAttribute('open','');
    }
    function closeDeleteCharDialog() {
      try { deleteCharDialog.close && deleteCharDialog.close(); } catch {}
      deleteCharDialog.removeAttribute('open');
      deleteTargetCharId = null;
      deleteTargetCharName = '';
    }
    async function confirmDeleteCharacter() {
      const id = deleteTargetCharId;
      if (!id) { closeDeleteCharDialog(); return; }
      try {
        const res = await fetch(`${API_BASE}/characters/${id}`, { method: 'DELETE' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        if (localStorage.getItem('selectedCharacterId') === String(id)) {
          localStorage.removeItem('selectedCharacterId');
        }
        await loadCharacters();
        personaSelect.value = '';
        applyCharacterSelection('');
        closeDeleteCharDialog();
      } catch (e) {
        console.error('Delete character failed', e);
        alert('Could not delete character');
      }
    }
    deleteCharDialog.addEventListener('cancel', (e) => { e.preventDefault(); closeDeleteCharDialog(); });
    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'dchar-cancel') { closeDeleteCharDialog(); }
      if (e.target && e.target.id === 'dchar-confirm') { confirmDeleteCharacter(); }
    });

    // --- View Prompt Modal ---
    const viewPromptDialog = document.createElement('dialog');
    viewPromptDialog.id = 'view-prompt-dialog';
    viewPromptDialog.innerHTML = `
      <form method="dialog" id="view-prompt-form" style="min-width: min(96vw, 680px); max-width: 96vw; background:#2a2a2a; color:#e0e0e0; border:1px solid #666; border-radius:8px; padding:0.8rem;">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.5rem;">
          <strong>Current System Prompt</strong>
          <button value="cancel" title="Close" style="border:1px solid #666; background:#3a3a3a; color:#e0e0e0; border-radius:4px; padding:0.2rem 0.5rem; cursor:pointer">‚úñ</button>
        </div>
        <textarea id="vp-text" readonly rows="10" style="width:100%; resize:vertical; padding:0.6rem; border:1px solid #555; background:#1f1f1f; color:#e0e0e0; border-radius:6px;"></textarea>
        <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.8rem;">
          <button id="vp-close" type="button" class="secondary" style="border:1px solid #666; background:#3a3a3a; color:#e0e0e0; border-radius:4px; padding:0.4rem 0.8rem; cursor:pointer">Close</button>
          <button id="vp-copy" type="button" style="border:1px solid #666; background:#4a4a4a; color:#fff; border-radius:4px; padding:0.4rem 0.8rem; cursor:pointer">Copy</button>
        </div>
      </form>`;
    document.body.appendChild(viewPromptDialog);
    function openViewPromptDialog() {
      const ta = viewPromptDialog.querySelector('#vp-text');
      if (ta) ta.value = buildEffectiveSystemPrompt();
      if (typeof viewPromptDialog.showModal === 'function') viewPromptDialog.showModal();
      else viewPromptDialog.setAttribute('open','');
    }
    function closeViewPromptDialog() {
      try { viewPromptDialog.close && viewPromptDialog.close(); } catch {}
      viewPromptDialog.removeAttribute('open');
    }
    async function copyViewPromptToClipboard() {
      try {
        const ta = viewPromptDialog.querySelector('#vp-text');
        const text = ta ? ta.value : '';
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          ta.select(); document.execCommand('copy'); ta.blur();
        }
      } catch {}
    }
    viewPromptDialog.addEventListener('cancel', (e) => { e.preventDefault(); closeViewPromptDialog(); });
    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'vp-close') { closeViewPromptDialog(); }
      if (e.target && e.target.id === 'vp-copy') { copyViewPromptToClipboard(); }
    });
    const landing = document.getElementById('landing');
    const chatInterface = document.getElementById('chat-interface');
    const conversationsDiv = document.getElementById('conversations');
    const chatDiv = document.getElementById('chat');
    const promptInput = document.getElementById('prompt');
    const personaSelect = document.getElementById('persona-select');
    // voice-select removed; voices handled via character form and cached map
    const profileName = document.getElementById('profile-name');
    const profileAvatar = document.getElementById('profile-avatar');
    const userIdField = document.getElementById('user-id');
    const backBtn = document.getElementById('back-btn');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsPanel = document.getElementById('settings-panel');
    const apiKeysList = document.getElementById('api-keys-list');
    const addKeyBtn = document.getElementById('add-key-btn');
    const closeSettingsBtn = document.getElementById('close-settings-btn');

    const synth = window.speechSynthesis;
    let audioCtx; // for UI beeps
    // Track current ElevenLabs audio playback so we can cancel it
    let currentTtsAudio = null;
    let currentTtsUrl = null;
    // Stop all ongoing speech/audio helpers
    function stopAllSpeech() {
      try { synth.cancel(); } catch (e) {}
      try {
        if (currentTtsAudio) {
          currentTtsAudio.pause();
          currentTtsAudio.src = '';
        }
        if (currentTtsUrl) URL.revokeObjectURL(currentTtsUrl);
      } catch (e) {}
      currentTtsAudio = null;
      currentTtsUrl = null;
      try { stopSpeakingIndicator(); } catch (e) {}
    }
    // Speaking indicator helpers (Level A)
    function startSpeakingIndicator() {
      try { profileAvatar.classList.add('speaking'); } catch (e) {}
    }
    function stopSpeakingIndicator() {
      try { profileAvatar.classList.remove('speaking'); } catch (e) {}
    }

    // Softens risky terms in avatar prompts to avoid safety rejections
    function softenAvatarPrompt(txt) {
      if (!txt) return 'Friendly cartoon portrait, kid-safe, G-rated, no violence, no weapons.';
      let s = String(txt);
      const repl = [
        [/\bedge of a cliff\b/gi, 'rocky ledge'],
        [/\bcliff\b/gi, 'rocky ledge'],
        [/\bclub\b/gi, 'walking stick'],
        [/\bweapon(s)?\b/gi, 'toy prop'],
        [/\bknife(s)?\b/gi, 'plastic kitchen tool'],
        [/\bgun(s)?\b/gi, 'toy gadget'],
        [/\bsword(s)?\b/gi, 'foam sword'],
        [/\baxe(s)?\b/gi, 'wooden tool'],
        [/\bspear(s)?\b/gi, 'wooden staff'],
        [/\bblood(y)?\b/gi, 'muddy'],
        [/\bgore(y)?\b/gi, 'messy'],
        [/\bkill(ed|ing)?\b/gi, 'defeat'],
        [/\bdead\b/gi, 'asleep'],
        [/\bdeath\b/gi, 'asleep'],
        [/\bcorpse\b/gi, 'figure'],
        [/\bmeat\b/gi, 'meal'],
        [/\bflame(s|d|ing)?\b/gi, 'glow'],
      ];
      for (const [re, to] of repl) s = s.replace(re, to);
      // Append clear kid-safe constraints if not present
      const tail = ' kid-safe, G-rated, friendly colorful cartoon, no violence, no weapons, simple background.';
      if (!/kid-safe|G-rated|no\s+violence|no\s+weapons/i.test(s)) s = s.trim().replace(/[\.;:,]*$/, '') + tail;
      return s;
    }

    let systemPrompt = '';
    let userId = null;
    // --- API_BASE handling ---
    // We normalize the base path so this frontend works both:
    //   1) at domain root (e.g. https://example.com/) ‚Üí API_BASE = ""
    //   2) at an Nginx subpath (e.g. https://example.com/lab/) ‚Üí API_BASE = "/lab"
    // This way all fetches remain relative to the correct app context without hardcoding.
    // The regex /\/$/ trims a trailing slash for consistency.
    const API_BASE = window.location.pathname.replace(/\/$/, "");
 
    function resolveUrl(u) {
     if (!u) return u;
     if (/^https?:\/\//i.test(u)) return u;       // already absolute
     if (u.startsWith(API_BASE + '/')) return u;  // already prefixed
     if (u.startsWith('/')) return API_BASE + u;  // '/assets/...' -> '/lab/assets/...'
     return API_BASE + '/' + u.replace(/^\.?\//, '');
   }

    async function loadApiKeys() {
      try {
        const res = await fetch(`${API_BASE}/settings/api_keys`);
        const data = await res.json();
        apiKeysList.innerHTML = '';
        const req = document.getElementById('api-keys-required');
        if (req) {
          const required = [
            { name: 'OPENROUTER_API_KEY', info: 'Required for chat (LLMs via OpenRouter).'},
            { name: 'OPENAI_API_KEY', info: 'Required for speech transcription and avatar generation.'},
            { name: 'ELEVENLABS_API_KEY', info: 'Required for ElevenLabs TTS voices and audio.'},
          ];
          const present = new Set((data.keys || []).filter(k => k && k.name && k.has_value).map(k => k.name));
          req.innerHTML = '';
          const hdr = document.createElement('div');
          hdr.style.marginBottom = '0.25rem';
          hdr.textContent = 'Required keys for full functionality:';
          req.appendChild(hdr);
          required.forEach(item => {
            const row = document.createElement('div');
            row.className = 'api-key-row';
            const name = document.createElement('span');
            name.textContent = item.name;
            const desc = document.createElement('span');
            desc.textContent = item.info;
            const btn = document.createElement('button');
            const isSet = present.has(item.name);
            btn.textContent = isSet ? 'Update' : 'Set';
            btn.onclick = async () => {
              const v = prompt(`${item.name} value:`);
              if (v === null) return;
              const trimmed = (v || '').trim();
              if (!trimmed) return;
              await fetch(`${API_BASE}/settings/api_keys`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: item.name, value: trimmed })
              });
              loadApiKeys();
            };
            row.appendChild(name);
            row.appendChild(desc);
            row.appendChild(btn);
            req.appendChild(row);
          });
        }
        (data.keys || []).forEach((k) => {
          const row = document.createElement('div');
          row.className = 'api-key-row';
          const name = document.createElement('span');
          name.textContent = k.name;
          const value = document.createElement('span');
          // Do not reveal the stored key value in the UI
          value.textContent = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
          const editBtn = document.createElement('button');
          editBtn.textContent = 'Edit';
          editBtn.onclick = async () => {
            // Ask for a new value without showing the current one.
            const nv = prompt('Enter new value for ' + k.name + ' (leave blank to keep current):', '');
            if (nv === null) return; // cancelled
            const trimmed = (nv || '').trim();
            if (!trimmed) return; // no change
            await fetch(`${API_BASE}/settings/api_keys`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: k.name, value: trimmed })
            });
            loadApiKeys();
          };
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Delete';
          delBtn.onclick = async () => {
            if (!confirm('Delete ' + k.name + '?')) return;
            await fetch(`${API_BASE}/settings/api_keys/` + encodeURIComponent(k.name), { method: 'DELETE' });
            loadApiKeys();
          };
          row.appendChild(name);
          row.appendChild(value);
          row.appendChild(editBtn);
          row.appendChild(delBtn);
          apiKeysList.appendChild(row);
        });
      } catch (e) {
        console.error('loadApiKeys', e);
      }
    }

    async function loadConversations() {
      try {
        // Ensure characters are loaded so convo thumbnails can borrow avatars
        if (!Array.isArray(window.characters) || !window.characters.length) {
          try { await loadCharacters(); } catch (e) {}
        }
        const res = await fetch(`${API_BASE}/users`);
        const data = await res.json();
        const users = data.users || [];
        conversationsDiv.innerHTML = '';
        if (!users.length) {
          const p = document.createElement('p');
          p.textContent = 'No conversations yet.';
          conversationsDiv.appendChild(p);
          return;
        }
        users.forEach((u) => {
          let prefs = {};
          try { prefs = u.preferences ? JSON.parse(u.preferences) : {}; } catch (e) {}
          // Borrow avatar from referenced character if prefs.avatar is empty
          let avatarUrl = (prefs.avatar || '');
          if (!avatarUrl && (prefs.character_id || prefs.character_name)) {
            try {
              const id = String(prefs.character_id || '');
              const name = (prefs.character_name || '').trim();
              let ch = null;
              if (Array.isArray(window.characters) && window.characters.length) {
                ch = id ? window.characters.find(c => String(c.id) === id)
                        : window.characters.find(c => (c.name || '') === name);
              }
              if (ch && ch.avatar) avatarUrl = ch.avatar;
            } catch (e) {}
          }
          const row = document.createElement('div');
          row.className = 'convo-row';
          const thumb = document.createElement('img');
          thumb.className = 'convo-thumb';
          if (avatarUrl) thumb.src = avatarUrl; else thumb.alt = 'avatar';
          const info = document.createElement('div');
          info.className = 'convo-info';
          const title = document.createElement('div');
          title.className = 'convo-title';
          title.textContent = u.name;
          const meta = document.createElement('div');
          meta.className = 'convo-meta';
          const voice = prefs.voice_name || prefs.voice_id || '';
          const sp = prefs.system_prompt ? prefs.system_prompt.replace(/\s+/g, ' ').slice(0, 140) : '';
          meta.textContent = [voice ? `Voice: ${voice}` : null, sp ? `Prompt: ${sp}` : null].filter(Boolean).join('  ‚Ä¢  ');
          info.appendChild(title);
          info.appendChild(meta);
          const openBtn = document.createElement('button');
          openBtn.textContent = 'Open';
          openBtn.onclick = () => selectConversation(u);
          const del = document.createElement('button');
          del.textContent = 'Delete';
          del.onclick = (e) => {
            e.stopPropagation();
            openDeleteConvoDialog(u);
          };
          const ren = document.createElement('button');
          ren.textContent = 'Rename';
          ren.onclick = async (e) => {
            e.stopPropagation();
            let newName = prompt('New name (leave blank for AI/auto):', u.name);
            if (newName === null) return; // cancelled
            newName = newName.trim();
            if (!newName) {
              try {
                // Try LLM summary suggestion first
                const s = await fetch(`${API_BASE}/users/${u.id}/suggest_name`, { method: 'POST' });
                if (s.ok) {
                  const j = await s.json();
                  newName = j.name || '';
                }
                if (!newName) {
                  const s2 = await fetch(`${API_BASE}/conversations/suggest_name`);
                  const j2 = await s2.json();
                  newName = j2.name || u.name;
                }
              } catch (e) { newName = u.name; }
            }
            try {
              const resp = await fetch(`${API_BASE}/users/${u.id}/name?name=` + encodeURIComponent(newName), { method: 'PUT' });
              if (!resp.ok) throw new Error('Rename failed');
              loadConversations();
            } catch (e) {
              alert('Rename failed');
            }
          };
          row.appendChild(thumb);
          row.appendChild(info);
          row.appendChild(openBtn);
          row.appendChild(ren);
          row.appendChild(del);
          conversationsDiv.appendChild(row);
        });
      } catch (e) {
        console.error('Failed to load conversations', e);
        conversationsDiv.textContent = 'Failed to load conversations';
      }
    }

    async function selectConversation(convo) {
      try {
        const res = await fetch(`${API_BASE}/users`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: convo.name })
        });
        if (!res.ok) throw new Error('User creation failed');
        const data = await res.json();
        userIdField.value = data.id;
        landing.style.display = 'none';
        chatInterface.style.display = 'block';
        profileName.textContent = convo.name;
        // Apply conversation avatar if present in preferences JSON
        try {
          const prefs = data.preferences ? JSON.parse(data.preferences) : {};
          if (prefs && prefs.avatar) {
            try { profileAvatar.src = prefs.avatar; } catch (e) {}
            try { document.getElementById('chat-avatar-bg').style.backgroundImage = `url('${prefs.avatar}')`; } catch (e) {}
          } else {
            try { document.getElementById('chat-avatar-bg').style.backgroundImage = ''; } catch (e) {}
          }
          // Apply stored system prompt / voice / character
          if (prefs && prefs.system_prompt) { systemPrompt = prefs.system_prompt; } else { systemPrompt = ''; }
          if (prefs && prefs.voice_id) { window.ELEVENLABS_VOICE_ID = prefs.voice_id; }
          else { window.ELEVENLABS_VOICE_ID = ''; }
          const pendingId = prefs && prefs.character_id ? String(prefs.character_id) : '';
          const pendingName = prefs && prefs.character_name ? String(prefs.character_name) : '';
          if (pendingId) {
            window.__pendingCharacterIdForConvo = pendingId;
          } else {
            window.__pendingCharacterIdForConvo = null;
            if (personaSelect) personaSelect.value = '';
          }
          window.__pendingCharacterNameForConvo = pendingName || '';
          // If characters are already loaded, try to apply the character immediately
          try {
            if (Array.isArray(characters) && characters.length && (pendingId || pendingName)) {
              let target = null;
              if (pendingId) target = characters.find(c => String(c.id) === String(pendingId));
              if (!target && pendingName) target = characters.find(c => (c.name || '') === pendingName);
              if (target) {
                personaSelect.value = String(target.id);
                applyCharacterSelection(String(target.id));
              } else {
                // Refresh characters to ensure latest, which will also apply selection via pending values
                loadCharacters();
              }
            }
          } catch (e) {}
        } catch (e) {}
        loadHistory();
      } catch (err) {
        console.error('Failed to create user', err);
        alert('Could not open conversation. Please try again.');
      }

    }

    // Characters (Personas) handling
    let characters = [];
    try { window.characters = characters; } catch (e) {}
    function applyCharacterSelection(id) {
      const ch = characters.find(c => String(c.id) === String(id));
      if (!ch) {
        systemPrompt = '';
        return;
      }
      systemPrompt = ch.system_prompt || '';
      // Set voice if defined
      if (ch.voice_id) {
        window.ELEVENLABS_VOICE_ID = ch.voice_id;
      }
      // Optional: swap avatar if provided and set chat background
      const bgEl = document.getElementById('chat-avatar-bg');
      if (ch.avatar) {
        try { profileAvatar.src = ch.avatar; } catch (e) {}
        try { if (bgEl) bgEl.style.backgroundImage = `url('${ch.avatar}')`; } catch (e) {}
      } else {
        try { if (bgEl) bgEl.style.backgroundImage = ''; } catch (e) {}
      }
      try { localStorage.setItem('selectedCharacterId', String(ch.id)); } catch (e) {}
      // Persist conversation meta (system prompt, character, voice)
      const uid = userIdField.value;
      if (uid) {
        const voiceId = (window.ELEVENLABS_VOICE_ID || '').trim();
        const voiceName = (window.__voiceMap && window.__voiceMap[voiceId]) ? window.__voiceMap[voiceId] : '';
        fetch(`${API_BASE}/users/${uid}/meta`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            system_prompt: systemPrompt,
            character_id: ch.id,
            character_name: ch.name || '',
            voice_id: voiceId,
            voice_name: voiceName
          })
        }).catch(() => {});
      }
    }

    personaSelect.addEventListener('change', () => {
      applyCharacterSelection(personaSelect.value);
    });

    async function loadCharacters() {
      try {
        const res = await fetch(`${API_BASE}/characters`);
        if (!res.ok) throw new Error(`characters http ${res.status}`);
        const data = await res.json();
        characters = data.characters || [];
        try { window.characters = characters; } catch (e) {}
        personaSelect.innerHTML = '';
        const def = document.createElement('option');
        def.value = '';
        def.textContent = 'Default';
        personaSelect.appendChild(def);
        for (const c of characters) {
          const opt = document.createElement('option');
          opt.value = c.id;
          opt.textContent = c.name;
          personaSelect.appendChild(opt);
        }
        // Preselect saved character by id or name
        const savedId = window.__pendingCharacterIdForConvo || localStorage.getItem('selectedCharacterId');
        const pendingName = (window.__pendingCharacterNameForConvo || '').trim();
        let applied = false;
        if (savedId && characters.some(c => String(c.id) === String(savedId))) {
          personaSelect.value = String(savedId);
          applyCharacterSelection(String(savedId));
          applied = true;
        } else if (pendingName) {
          const byName = characters.find(c => (c.name || '') === pendingName);
          if (byName) {
            personaSelect.value = String(byName.id);
            applyCharacterSelection(String(byName.id));
            applied = true;
          }
        }
        if (!applied) {
          personaSelect.value = '';
          systemPrompt = '';
        }
        // Populate new character voice selector with same voices
        fillCharVoiceOptions();
      } catch (e) {
        console.warn('Failed to load characters', e);
        personaSelect.innerHTML = '';
        const def = document.createElement('option');
        def.value = '';
        def.textContent = 'Default';
        personaSelect.appendChild(def);
        personaSelect.disabled = true;
      }
    }

    // New character UI
    const newCharBtn = document.getElementById('new-character-btn');
    const editCharBtn = document.getElementById('edit-character-btn');
    const deleteCharBtn = document.getElementById('delete-character-btn');
    const viewPromptBtn = document.getElementById('view-prompt-btn');
    const newCharForm = document.getElementById('new-character-form');
    const saveCharBtn = document.getElementById('save-character-btn');
    const cancelCharBtn = document.getElementById('cancel-character-btn');
    const genAvatarBtn = document.getElementById('generate-avatar-btn');
    const charVoiceManual = document.getElementById('char-voice-manual');
    const charVoiceManualToggle = document.getElementById('char-voice-manual-toggle');
    const charVoiceReload = document.getElementById('char-voice-reload');
    const charVoiceHint = document.getElementById('char-voice-hint');
    let editingCharacterId = null;
    function toggleNewChar(open) {
      newCharForm.style.display = open ? 'block' : 'none';
    }
    function fillCharVoiceOptions(selectedId) {
      const charVoice = document.getElementById('char-voice');
      if (!charVoice) return;
      const current = (typeof selectedId !== 'undefined' && selectedId !== null)
        ? String(selectedId)
        : String(charVoice.value || '');
      charVoice.innerHTML = '<option value="">(use current voice)</option>';
      const list = Array.isArray(window.__voices) ? window.__voices : [];
      for (const v of list) {
        const id = v.voice_id || '';
        if (!id) continue;
        const o = document.createElement('option');
        o.value = id; o.text = v.name || id;
        charVoice.add(o);
      }
      // Try to restore selection
      if (current) {
        try { charVoice.value = current; } catch {}
      }
      // Toggle manual entry visibility and hint
      if (!list.length) {
        if (charVoiceHint) charVoiceHint.textContent = 'No voices loaded. Set ELEVENLABS_API_KEY in Settings, then Reload or enter an ID.';
        if (charVoiceManual) charVoiceManual.style.display = 'block';
      } else {
        if (charVoiceHint) charVoiceHint.textContent = '';
        if (charVoiceManual && !charVoiceManual.value) charVoiceManual.style.display = 'none';
      }
    }
    function openCharacterFormForNew() {
      editingCharacterId = null;
      fillCharVoiceOptions(window.ELEVENLABS_VOICE_ID || '');
      if (charVoiceManual) {
        charVoiceManual.value = '';
        charVoiceManual.style.display = 'none';
      }
      document.getElementById('char-name').value = '';
      document.getElementById('char-prompt').value = '';
      document.getElementById('char-avatar').value = '';
      const cv = document.getElementById('char-voice');
      if (cv) cv.value = (window.ELEVENLABS_VOICE_ID || '');
      document.getElementById('save-character-btn').textContent = 'Save';
      toggleNewChar(true);
    }
    function openCharacterFormForEdit(id) {
      const ch = characters.find(c => String(c.id) === String(id));
      if (!ch) { alert('Select a character to edit'); return; }
      editingCharacterId = ch.id;
      fillCharVoiceOptions(ch.voice_id || '');
      if (charVoiceManual) {
        charVoiceManual.value = ch.voice_id || '';
        // Only show manual if no voices list available
        const list = Array.isArray(window.__voices) ? window.__voices : [];
        charVoiceManual.style.display = list.length ? 'none' : 'block';
      }
      document.getElementById('char-name').value = ch.name || '';
      document.getElementById('char-prompt').value = ch.system_prompt || '';
      document.getElementById('char-avatar').value = ch.avatar || '';
      const cv = document.getElementById('char-voice');
      if (cv) cv.value = ch.voice_id || '';
      document.getElementById('save-character-btn').textContent = 'Update';
      toggleNewChar(true);
    }
    if (newCharBtn) newCharBtn.onclick = () => openCharacterFormForNew();
    if (editCharBtn) editCharBtn.onclick = () => {
      const id = personaSelect.value;
      if (!id) { alert('Select a character first'); return; }
      openCharacterFormForEdit(id);
    };
    if (deleteCharBtn) deleteCharBtn.onclick = () => openDeleteCharDialog();
    if (viewPromptBtn) viewPromptBtn.onclick = () => openViewPromptDialog();
    if (cancelCharBtn) cancelCharBtn.onclick = () => toggleNewChar(false);
    if (saveCharBtn) saveCharBtn.onclick = async () => {
      const name = document.getElementById('char-name').value.trim();
      const prompt = document.getElementById('char-prompt').value;
      const avatar = document.getElementById('char-avatar').value.trim();
      const voiceSel = document.getElementById('char-voice').value.trim();
      const voiceMan = (charVoiceManual && charVoiceManual.style.display !== 'none' ? (charVoiceManual.value || '').trim() : '');
      const voice = voiceMan || voiceSel;
      if (!name) { alert('Please provide a character name'); return; }
      try {
        const isEdit = !!editingCharacterId;
        const url = isEdit ? `${API_BASE}/characters/${editingCharacterId}` : `${API_BASE}/characters`;
        const method = isEdit ? 'PUT' : 'POST';
        const res = await fetch(url, {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, system_prompt: prompt, voice_id: voice, avatar })
        });
        if (!res.ok) {
          const t = await res.text().catch(() => '');
          throw new Error(t || `HTTP ${res.status}`);
        }
        const created = await res.json();
        toggleNewChar(false);
        editingCharacterId = null;
        // Clear form
        document.getElementById('char-name').value = '';
        document.getElementById('char-prompt').value = '';
        document.getElementById('char-avatar').value = '';
        document.getElementById('char-voice').value = '';
        // Reload characters and select the new one
        await loadCharacters();
        const selectId = created.id;
        personaSelect.value = selectId;
        applyCharacterSelection(selectId);
      } catch (e) {
        console.error('Create character failed', e);
        alert('Could not save character');
      }
    };

    if (charVoiceReload) charVoiceReload.onclick = () => {
      loadVoices();
    };
    if (charVoiceManualToggle) charVoiceManualToggle.onclick = () => {
      if (!charVoiceManual) return;
      const visible = charVoiceManual.style.display !== 'none';
      charVoiceManual.style.display = visible ? 'none' : 'block';
      try { if (!visible) charVoiceManual.focus(); } catch {}
    };

    if (genAvatarBtn) genAvatarBtn.onclick = async () => {
      const targetId = editingCharacterId || personaSelect.value;
      if (!targetId) { alert('Select or save a character first'); return; }
      const styleSel = document.getElementById('char-avatar-style');
      const style = styleSel ? styleSel.value : '';
      const sizeSel = document.getElementById('char-avatar-size');
      const size = sizeSel ? sizeSel.value : '512x512';
      const promptEl = document.getElementById('char-avatar-prompt');
      const prompt = promptEl ? promptEl.value.trim() : '';
      genAvatarBtn.disabled = true;
      const incSpEl = document.getElementById('char-avatar-include-sp');
      const include_system_prompt = !!(incSpEl && incSpEl.checked);
      const oldText = genAvatarBtn.textContent;
      genAvatarBtn.textContent = 'Generating‚Ä¶';
      try {
        const res = await fetch(`${API_BASE}/characters/${targetId}/avatar/generate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ style, prompt, size, include_system_prompt })
        });
        if (!res.ok) {
          const t = await res.text().catch(() => 'Unknown error');
          throw new Error(t);
        }
        const data = await res.json();
        const url = data.avatar;
        const idx = characters.findIndex(c => String(c.id) === String(targetId));
        if (idx >= 0) characters[idx].avatar = url;
        if (String(personaSelect.value) === String(targetId)) {
          try { profileAvatar.src = url; } catch (e) {}
          try { document.getElementById('chat-avatar-bg').style.backgroundImage = `url('${url}')`; } catch (e) {}
        }
        const avatarInput = document.getElementById('char-avatar');
        if (avatarInput) avatarInput.value = url;
        // Also store this avatar against the current conversation so it persists per conversation
        const uid = userIdField.value;
        if (uid) {
          try {
            await fetch(`${API_BASE}/users/${uid}/avatar`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ avatar: url })
            });
          } catch (e) { /* ignore */ }
        }
      } catch (e) {
        console.error('Avatar generation failed', e);
        let msg = 'Avatar generation failed';
        try {
          const raw = String(e && e.message ? e.message : e);
          // Try to parse FastAPI structured error with suggestion
          if (raw.trim().startsWith('{')) {
            const outer = JSON.parse(raw);
            let body = outer.detail || raw;
            if (typeof body === 'string' && body.trim().startsWith('{')) {
              try { body = JSON.parse(body); } catch (_) {}
            }
            const text = (body && body.error && body.error.message) || body.message || String(body);
            const suggested = body && body.suggestion;
            if (suggested) {
              const promptEl = document.getElementById('char-avatar-prompt');
              if (promptEl) promptEl.value = suggested;
              msg = `Requested avatar was rejected due to content policies. Please modify your prompt and try again.\n\nSuggested edit:\n${suggested}`;
            } else if (text && /content_policy_violation|safety system|rejected/i.test(text)) {
              const promptEl = document.getElementById('char-avatar-prompt');
              const current = promptEl ? promptEl.value : '';
              const softened = softenAvatarPrompt(current);
              if (promptEl && softened) promptEl.value = softened;
              msg = `Requested avatar was rejected due to content policies. Please modify your prompt and try again.\n\nSuggested edit:\n${softened}`;
            } else if (text) {
              msg = `Avatar generation failed: ${text}`;
            }
          } else if (/content_policy_violation|safety system|rejected/i.test(raw)) {
            const promptEl = document.getElementById('char-avatar-prompt');
            const current = promptEl ? promptEl.value : '';
            const softened = softenAvatarPrompt(current);
            if (promptEl && softened) promptEl.value = softened;
            msg = `Requested avatar was rejected due to content policies. Please modify your prompt and try again.\n\nSuggested edit:\n${softened}`;
          }
        } catch (_) {}
        alert(msg);
      } finally {
        genAvatarBtn.disabled = false;
        genAvatarBtn.textContent = oldText;
      }
    };

    async function loadVoices() {
      try {
        const res = await fetch(`${API_BASE}/tts/voices`);
        if (!res.ok) throw new Error(`voices http ${res.status}`);
        const data = await res.json();
        const saved = (localStorage.getItem('elevenlabsVoiceId') || '').trim();
        const cfg = (window.ELEVENLABS_VOICE_ID || '').trim();
        const preferred = saved || cfg;
        const list = Array.isArray(data.voices) ? data.voices : [];
        window.__voices = list;
        window.__voiceMap = {};
        for (const v of list) {
          if (v.voice_id) window.__voiceMap[v.voice_id] = v.name || v.voice_id;
        }
        // Default global voice
        if (!window.ELEVENLABS_VOICE_ID) {
          window.ELEVENLABS_VOICE_ID = preferred || (list[0] && list[0].voice_id) || '';
        }
        // Refresh character voice select if open
        fillCharVoiceOptions();
      } catch (e) {
        console.warn('Failed to load ElevenLabs voices (perhaps no API key?)', e);
        window.__voices = [];
        window.__voiceMap = {};
        fillCharVoiceOptions();
      }
    }

    function buildEffectiveSystemPrompt() {
      let effectiveSystemPrompt = systemPrompt || '';
      try {
        const selId = personaSelect && personaSelect.value;
        if (selId) {
          const ch = (characters || []).find(c => String(c.id) === String(selId));
          const cname = (ch && ch.name ? String(ch.name) : '').trim();
          if (cname) {
            effectiveSystemPrompt = `Your name is ${cname}. ` + (effectiveSystemPrompt || '');
          }
        }
      } catch (e) {}
      return effectiveSystemPrompt;
    }

    async function sendMessage(text) {
      const message = text || promptInput.value;
      if (!message) return;
      appendMessage('user', message);
      promptInput.value = '';

      // Build effective system prompt including transparent additions
      const effectiveSystemPrompt = buildEffectiveSystemPrompt();

      const response = await fetch(`${API_BASE}/chat/stream`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: userIdField.value,
          message,
          system_prompt: effectiveSystemPrompt
        })
      });

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      const botP = appendMessage('bot', '');
      let botText = '';
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        botText += chunk;
        botP.textContent += chunk;
        chatDiv.scrollTop = chatDiv.scrollHeight;
      }
      // Speak only if enabled
      const speechToggle = document.getElementById('speech-toggle');
      const wantSpeech = !speechToggle || speechToggle.value === 'on';
      if (wantSpeech) {
        speak(botText);
      }
    }

    // Enter submits; Shift+Enter creates newline
    if (promptInput) {
      promptInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          document.getElementById('send-btn').click();
        }
      });
    }

    async function loadHistory() {
      chatDiv.innerHTML = '';
      const userId = userIdField.value;
      if (!userId) return;
      const res = await fetch(`${API_BASE}/users/${userId}/history`);
      const data = await res.json();
      data.history.forEach(msg => appendMessage(msg.role, msg.content));
    }

    function appendMessage(sender, text) {
      const p = document.createElement('p');
      p.className = sender;
      p.textContent = text;
      chatDiv.appendChild(p);
      chatDiv.scrollTop = chatDiv.scrollHeight;
      return p;
    }

    function sanitizeForTTS(s) {
      if (!s) return '';
      let t = String(s);
      // Remove emote/gesture text enclosed in single asterisks, e.g., *opens door slowly*
      // Keep surrounding spacing/punctuation tidy.
      t = t.replace(/(^|\s)\*([^*]+)\*(?=\s|$|[.,!?:;])/g, (m, pre) => pre || ' ');
      // Collapse newlines and extra spaces
      t = t.replace(/[\r\n]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
      return t;
    }

    async function speak(text) {
      // Respect toggle immediately
      const st = document.getElementById('speech-toggle');
      if (st && st.value === 'off') return;

      // Strip gesture-like *text* which does not read well in TTS
      const safeText = sanitizeForTTS(text);

      // Stop any ongoing speech first to avoid overlap
      try { synth.cancel(); } catch (e) {}
      try {
        if (currentTtsAudio) {
          currentTtsAudio.pause();
          currentTtsAudio.src = '';
        }
        if (currentTtsUrl) {
          URL.revokeObjectURL(currentTtsUrl);
        }
      } catch (e) {}
      currentTtsAudio = null;
      currentTtsUrl = null;

      // Try ElevenLabs via streaming endpoint first; fall back to buffered /tts, then browser TTS
      try {
        const voiceId = (window.ELEVENLABS_VOICE_ID || '').trim();
        if (!voiceId) {
          console.info('[speak] Skipping ElevenLabs: no voice configured (set window.ELEVENLABS_VOICE_ID)');
        } else {
          console.info('[speak] Attempting ElevenLabs streaming via /tts/stream with voice:', voiceId);
          // Check toggle again before playing
          if (st && st.value === 'off') return;
          const streamUrl = `${API_BASE}/tts/stream?voice_id=${encodeURIComponent(voiceId)}&text=${encodeURIComponent(safeText)}`;
          const audio = new Audio(streamUrl);
          currentTtsAudio = audio;
          currentTtsUrl = null; // using URL directly, not object URL
          audio.play().then(() => {
            console.info('[speak] Playing ElevenLabs streaming audio');
            try { profileAvatar.classList.add('speaking'); } catch (e) {}
          }).catch(async (err) => {
            console.warn('[speak] Streaming play failed, trying buffered /tts', err);
            // Buffered fallback
            try {
              const res = await fetch(`${API_BASE}/tts`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: safeText, voice_id: voiceId })
              });
              const ct = res.headers.get('content-type') || '';
              if (res.ok && ct.includes('audio')) {
                const blob = await res.blob();
                if (blob.size > 0) {
                  if (st && st.value === 'off') return;
                  const url = URL.createObjectURL(blob);
                  const a2 = new Audio(url);
                  currentTtsAudio = a2;
                  currentTtsUrl = url;
                  a2.play().then(() => {
                    console.info('[speak] Playing buffered ElevenLabs audio');
                    try { profileAvatar.classList.add('speaking'); } catch (e) {}
                  }).catch((err2) => {
                    console.warn('[speak] Buffered play blocked; will fallback to speechSynthesis', err2);
                    if (!st || st.value !== 'off') {
                      const u = new SpeechSynthesisUtterance(safeText);
                      u.onstart = () => { try { profileAvatar.classList.add('speaking'); } catch (e) {} };
                      u.onend = () => { try { profileAvatar.classList.remove('speaking'); } catch (e) {} };
                      synth.speak(u);
                    }
                  });
                  a2.onended = () => {
                    if (currentTtsUrl) URL.revokeObjectURL(currentTtsUrl);
                    currentTtsUrl = null;
                    currentTtsAudio = null;
                    try { profileAvatar.classList.remove('speaking'); } catch (e) {}
                  };
                  return;
                }
              }
            } catch (e2) {
              console.warn('[speak] Buffered /tts failed', e2);
            }
            // Final fallback below
          });
          // For streaming path, ensure we clear indicator when stream ends
          audio.onended = () => {
            currentTtsAudio = null;
            try { profileAvatar.classList.remove('speaking'); } catch (e) {}
          };
          return;
        }
      } catch (e) {
        console.error('[speak] ElevenLabs flow threw error; falling back to speechSynthesis', e);
      }
      // Browser speech synthesis fallback
      const utterance = new SpeechSynthesisUtterance(text);
      console.info('[speak] Using browser SpeechSynthesis');
      if (!st || st.value !== 'off') {
        utterance.onstart = () => { try { profileAvatar.classList.add('speaking'); } catch (e) {} };
        utterance.onend = () => { try { profileAvatar.classList.remove('speaking'); } catch (e) {} };
        synth.speak(utterance);
      }
    }

    async function exportConversation() {
      const userId = userIdField.value;
      if (!userId) {
        alert('No user selected');
        return;
      }
      try {
        const res = await fetch(`${API_BASE}/users/${userId}/history`);
        if (!res.ok) throw new Error('Failed to fetch history');
        const data = await res.json();
        const formatSel = document.getElementById('export-format');
        const format = (formatSel && formatSel.value) || 'markdown';
        const filenameBase = `conversation-${new Date().toISOString().replace(/[:.]/g,'-')}`;
        let blob;
        if (format === 'json') {
          blob = new Blob([JSON.stringify(data.history, null, 2)], { type: 'application/json' });
          triggerDownload(blob, `${filenameBase}.json`);
        } else if (format === 'text') {
          const lines = data.history.map(h => `${h.role.toUpperCase()}: ${h.content}`);
          blob = new Blob([lines.join('\n\n')], { type: 'text/plain' });
          triggerDownload(blob, `${filenameBase}.txt`);
        } else {
          // markdown
          const header = `# Conversation Export\n\nGenerated: ${new Date().toLocaleString()}\n`;
          const body = data.history
            .map(h => `- **${h.role === 'bot' ? 'Assistant' : 'User'}**: ${h.content.replace(/\n/g, '  \n')}`)
            .join('\n');
          blob = new Blob([header + '\n' + body + '\n'], { type: 'text/markdown' });
          triggerDownload(blob, `${filenameBase}.md`);
        }
      } catch (err) {
        console.error('Export failed', err);
        alert('Could not export conversation');
      }
    }

    function triggerDownload(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    async function importConversationFromFile(file) {
      const userId = userIdField.value;
      if (!userId) {
        alert('No user selected');
        return;
      }
      try {
        const text = await file.text();
        const json = JSON.parse(text);
        // Normalize messages
        const arr = Array.isArray(json)
          ? json
          : (Array.isArray(json.history) ? json.history : (Array.isArray(json.messages) ? json.messages : []));
        if (!arr.length) {
          alert('No messages found in file');
          return;
        }
        const normalized = arr
          .map((m) => {
            const roleRaw = (m.role || '').toLowerCase();
            if (roleRaw === 'system') return null; // ignore system
            const role = roleRaw === 'assistant' ? 'bot' : roleRaw; // map assistant->bot
            const content = m.content || m.text || '';
            if (!content) return null;
            const timestamp = m.timestamp || null;
            if (role !== 'user' && role !== 'bot') return null;
            return { role, content, timestamp };
          })
          .filter(Boolean);
        if (!normalized.length) {
          alert('No importable messages in file');
          return;
        }
        const res = await fetch(`${API_BASE}/users/${userId}/history/import`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ messages: normalized }),
        });
        if (!res.ok) throw new Error('Import failed');
        await loadHistory();
        alert('Conversation imported');
      } catch (err) {
        console.error('Import failed', err);
        alert('Could not import conversation');
      }
    }

    // Push-to-talk recording logic
    let mediaStream = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let isProcessing = false;

    const listenBtn = document.getElementById('listen-btn');
    const recordingHint = document.getElementById('recording-hint');

    function setRecordingUI(active) {
      isRecording = !!active;
      listenBtn.classList.toggle('recording', active);
      recordingHint.classList.toggle('show', active);
      listenBtn.title = active ? 'Recording‚Ä¶ Click to stop (Shift+S)' : 'Push-to-talk (Shift+S)';
    }

    function setProcessingUI(active) {
      isProcessing = !!active;
      listenBtn.classList.toggle('processing', active);
      listenBtn.disabled = active; // avoid accidental clicks while processing
      if (active) {
        listenBtn.title = 'Transcribing‚Ä¶';
      } else if (!isRecording) {
        listenBtn.title = 'Push-to-talk (Shift+S)';
      }
    }

    function playBeep(freq = 880, durationSec = 0.06, volume = 0.06) {
      try {
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = volume;
        osc.type = 'sine';
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        setTimeout(() => { osc.stop(); osc.disconnect(); gain.disconnect(); }, durationSec * 1000);
      } catch (e) {
        // ignore beep errors
      }
    }

    async function beginRecording() {
      if (isRecording) return;
      if (isProcessing) return; // wait until transcription finishes
      try {
        // Stop any ongoing TTS/audio so mic capture doesn't overlap playback
        stopAllSpeech();
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioChunks = [];
        mediaRecorder = new MediaRecorder(mediaStream);
        mediaRecorder.ondataavailable = (e) => { if (e.data?.size) audioChunks.push(e.data); };
        mediaRecorder.onstop = async () => {
          // Stop all tracks to release the mic
          try { mediaStream.getTracks().forEach(t => t.stop()); } catch (e) {}
          try {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            if (blob.size === 0) { setRecordingUI(false); return; }
            const formData = new FormData();
            formData.append('file', blob, 'speech.webm');
            formData.append('model', 'whisper-1');
            setProcessingUI(true);
            const res = await fetch(`${API_BASE}/speech/transcribe`, {
              method: 'POST',
              body: formData
            });
            const data = await res.json();
            if (data?.text) {
              sendMessage(data.text);
            } else {
              console.error('Transcription error', data);
              alert('Transcription failed');
            }
          } catch (err) {
            console.error('Transcription request failed', err);
            alert('Transcription request failed');
          } finally {
            setRecordingUI(false);
            setProcessingUI(false);
            mediaRecorder = null;
            mediaStream = null;
            audioChunks = [];
          }
        };
        mediaRecorder.start();
        setRecordingUI(true);
        playBeep(880, 0.05, 0.05);
      } catch (err) {
        console.error('Could not access microphone', err);
        alert('Could not access microphone');
        setRecordingUI(false);
      }
    }

    function stopRecordingAndSend() {
      if (!isRecording) return;
      try {
        mediaRecorder?.stop();
        playBeep(440, 0.05, 0.05);
      } catch (e) {
        console.error('Error stopping recorder', e);
        setRecordingUI(false);
      }
    }

    // Click toggles start/stop
    function toggleRecording() {
      if (isProcessing) return; // ignore while transcribing
      if (isRecording) stopRecordingAndSend(); else beginRecording();
    }

    // Shift+S push-to-talk
    const pressed = new Set();
    let ptpActive = false;

    window.addEventListener('keydown', (e) => {
      // Track pressed keys for Shift and S
      if (e.code === 'KeyS') pressed.add('KeyS');
      if (e.key === 'Shift' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') pressed.add('Shift');

      if (!ptpActive && !isProcessing && pressed.has('Shift') && pressed.has('KeyS')) {
        ptpActive = true;
        // Stop any ongoing TTS immediately on push-to-talk
        try { stopAllSpeech(); } catch (err) {}
        beginRecording();
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'KeyS') pressed.delete('KeyS');
      if (e.key === 'Shift' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') pressed.delete('Shift');

      if (ptpActive && (!pressed.has('Shift') || !pressed.has('KeyS'))) {
        ptpActive = false;
        stopRecordingAndSend();
        e.preventDefault();
      }
    });

    // Set up speech toggle persistence and behavior
    const speechToggleEl = document.getElementById('speech-toggle');
    if (speechToggleEl) {
      try {
        const saved = localStorage.getItem('speechToggle');
        if (saved === 'on' || saved === 'off') speechToggleEl.value = saved;
      } catch (e) {}
      speechToggleEl.addEventListener('change', () => {
        try { localStorage.setItem('speechToggle', speechToggleEl.value); } catch (e) {}
        if (speechToggleEl.value === 'off') {
          try { synth.cancel(); } catch (e) {}
          try {
            if (currentTtsAudio) {
              currentTtsAudio.pause();
              currentTtsAudio.src = '';
            }
            if (currentTtsUrl) URL.revokeObjectURL(currentTtsUrl);
          } catch (e) {}
          currentTtsAudio = null;
          currentTtsUrl = null;
        }
      });
    }

    document.getElementById('send-btn').onclick = () => sendMessage();
    listenBtn.onclick = () => toggleRecording();
    const exportBtn = document.getElementById('export-btn');
    if (exportBtn) exportBtn.onclick = () => exportConversation();
    const importBtn = document.getElementById('import-btn');
    const importFile = document.getElementById('import-file');
    if (importBtn && importFile) {
      importBtn.onclick = () => importFile.click();
      importFile.onchange = () => {
        const file = importFile.files && importFile.files[0];
        if (file) importConversationFromFile(file);
        importFile.value = '';
      };
    }

    if (settingsBtn) settingsBtn.onclick = () => {
      settingsPanel.style.display = 'block';
      loadApiKeys();
    };
    if (closeSettingsBtn) closeSettingsBtn.onclick = () => {
      settingsPanel.style.display = 'none';
    };
    if (addKeyBtn) addKeyBtn.onclick = async () => {
      const name = prompt('API key name?');
      if (!name) return;
      const value = prompt('Value for ' + name + '?');
      if (value === null) return;
      await fetch(`${API_BASE}/settings/api_keys`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, value })
      });
      loadApiKeys();
    };

    const newConvoBtn = document.getElementById('new-convo-btn');
    console.log('loaded button');
    console.log(newConvoBtn);
    if (newConvoBtn) newConvoBtn.onclick = () => openNewConvoDialog();

    loadConversations();
    // Attempt to load ElevenLabs voices and characters; silently degrade if not configured
    loadVoices().finally(loadCharacters);
    
    // Back to conversations
    if (backBtn) backBtn.onclick = () => {
      stopAllSpeech();
      // Stop recording if active
      try {
        if (typeof isRecording !== 'undefined' && isRecording && mediaRecorder) {
          mediaRecorder.stop();
        }
      } catch (e) {}
      chatDiv.innerHTML = '';
      userIdField.value = '';
      profileName.textContent = '';
      landing.style.display = 'block';
      chatInterface.style.display = 'none';
      loadConversations();
    };
  </script>
</body>
</html>
